{

{-# OPTIONS_GHC -fno-warn-deprecated-flags
                -fno-warn-lazy-unlifted-bindings #-}
-- TODO
---- Nested comments: see examples in alex, GHC lexer, and Agda lexer
---- Unicode: see GHC lexer and Agda lexer (the latter seems simpler)

module Syntax.Lexer where

import Control.Monad.State

import Syntax.Tokens
import Syntax.Alex
import Syntax.ParseMonad

}

$digit = 0-9
$alpha = [ a-z A-Z _ ]

@number = $digit+
@ident = $alpha [ $alpha $digit \' ]*

tokens :-

  $white+       ;

  -- One-line and non-nested comments for the moment
  "--".* ;
  "{-" ([ [. \n] # \-] | \- [ [. \n] # \}])* ("-")+ "}" ;


  -- Type without a number is a synonym of Type0. See Syntax.Tokens.ident
  -- This should be guaranteed since Alex process the action with the longest
  -- match. Type3 should match this rule, while Type<not a number> should match
  -- rule @ident below
  Type @number      { typeKeyword }

  \(          { symbol }
  \)          { symbol }
  "->"        { symbol }
  "=>"        { symbol }
  ","         { symbol }
  ":="        { symbol }
  "."         { symbol }
  ":"         { symbol }
  "::"        { symbol }
  "|"         { symbol }
  "+"         { symbol }
  "-"         { symbol }
  "++"        { symbol }
  "@"         { symbol }
  "<"         { symbol }
  ">"         { symbol }
  "["         { symbol }
  "]"         { symbol }

  @ident      { ident }

{

-- wraps the Lexer generated by alex into the monad Parser

lexToken :: Parser Token
lexToken =
  do s <- get
     case alexScan s 0 of  -- 0 is the state of the lexer. Not used now
       AlexEOF -> return TokEOF
       AlexError inp' -> parseErrorAt (lexPos s) ("Lexical error") -- rest of input ingnored at the moment
       AlexSkip inp' len -> put inp' >> lexToken
       AlexToken inp' len act ->
         do put inp'
            return $ act (lexPos s) (take len (lexInput s))

lexer :: (Token -> Parser a) -> Parser a
lexer cont = lexToken >>= cont

}